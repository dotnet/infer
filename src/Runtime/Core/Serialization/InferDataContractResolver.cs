// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

namespace Microsoft.ML.Probabilistic.Serialization
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Runtime.Serialization;
    using System.Xml;
    using Pitchfork.TypeParsing;

    /// <summary>
    /// A data contract resolver that dynamically resolves known types.
    /// </summary>
    public class InferDataContractResolver : DataContractResolver
    {
        // URN prefix of namespaces generated by our contract resolver
        private const string nsPrefix = "urn:x-research.microsoft.com:Infer.NET:assemblyname:";

        private static readonly HashSet<Type> seenTypes = new HashSet<Type>();

        public override bool TryResolveType(
            Type type,
            Type declaredType,
            DataContractResolver knownTypeResolver,
            out XmlDictionaryString typeName,
            out XmlDictionaryString typeNamespace)
        {
            if (knownTypeResolver.TryResolveType(type, declaredType, knownTypeResolver, out typeName, out typeNamespace))
            {
                return true;
            }

            var dict = new XmlDictionary(2);
            typeName = dict.Add(type.FullName);
            typeNamespace = dict.Add(String.Concat(nsPrefix, type.Assembly.FullName));

            return true;
        }

        public override Type ResolveName(string typeName, string typeNamespace, Type declaredType, DataContractResolver knownTypeResolver)
        {
            var ty = knownTypeResolver.ResolveName(typeName, typeNamespace, declaredType, knownTypeResolver);

            if (ty != null) return ty;

            if (!typeNamespace.StartsWith(nsPrefix)) // Is this our namespace?
            {
                return null; // Cannot resolve.
            }

            // We limit the length of the type name we are willing to try to parse
            // for security reasons.
            if (typeName.Length > 10000)
            {
                throw new Exception("Type name exceeded maximum length");
            }

            // We avoid loading a type from a string for security reasons before we
            // first parse it to ensure that it is constructed from approved types.
            var typeId = TypeId.Parse(typeName, null);

            var allowedTypes = new[]
            {
                typeof(Microsoft.ML.Probabilistic.Distributions.Automata.StringAutomaton),
                typeof(Microsoft.ML.Probabilistic.Distributions.Automata.StringDictionaryWeightFunction),
                typeof(Microsoft.ML.Probabilistic.Distributions.Automata.StringManipulator),
                typeof(Microsoft.ML.Probabilistic.Distributions.Automata.Weight),
                typeof(Microsoft.ML.Probabilistic.Distributions.Automata.WeightFunctions<,,,,>.PointMassWeightFunction),
                typeof(Microsoft.ML.Probabilistic.Distributions.ConstantFunction),
                typeof(Microsoft.ML.Probabilistic.Distributions.DistributionRefArray<,>),
                typeof(Microsoft.ML.Probabilistic.Distributions.DistributionRefArray2D<,>),
                typeof(Microsoft.ML.Probabilistic.Distributions.DistributionStructArray<,>),
                typeof(Microsoft.ML.Probabilistic.Distributions.DistributionStructArray2D<,>),
                typeof(Microsoft.ML.Probabilistic.Distributions.Gaussian),
                typeof(Microsoft.ML.Probabilistic.Distributions.GaussianProcess),
                typeof(Microsoft.ML.Probabilistic.Distributions.ImmutableDiscreteChar),
                typeof(Microsoft.ML.Probabilistic.Distributions.Kernels.SquaredExponential),
                typeof(Microsoft.ML.Probabilistic.Distributions.VectorGaussian),
                // TODO: include all distributions
                typeof(Microsoft.ML.Probabilistic.Math.DenseVector),
                typeof(Microsoft.ML.Probabilistic.Math.Vector),
                typeof(System.Char),
                typeof(System.Collections.Generic.SortedList<,>),
                typeof(System.Double),
                typeof(System.String),
            };

            return ConstructTypeFromAllowedlist(typeId, allowedTypes);
        }

        private static Type ConstructTypeFromAllowedlist(TypeId type, Type[] allowedTypes)
        {
            // To avoid any possibility that an unexpected type is extracted from the string
            // this method creates the type entirely from the allowedTypes list. That way even
            // if there is an error in parsing of the type it is not possible for any type not
            // in the allowed list to be created.
            if (type.IsArrayType)
            {
                var itemType = type.GetUnderlyingType();
                var resolvedItemType = ConstructTypeFromAllowedlist(itemType, allowedTypes);
                return resolvedItemType.MakeArrayType();
            }

            if (!type.IsConstructedGenericType)
            {
                var allowedListGenericDefinition = allowedTypes.SingleOrDefault(allowedType => allowedType.FullName == type.Name);
                if (allowedListGenericDefinition == null)
                {
                    throw new Exception($"Type '{type.Name}' is not allowed.");
                }

                if (allowedListGenericDefinition.IsGenericTypeDefinition != type.IsConstructedGenericType)
                {
                    throw new Exception($"Invalid operation: allowed list entry '{allowedListGenericDefinition.FullName}' does not match typeId '{type}'.");
                }

                return allowedListGenericDefinition;
            }

            var genericDefinitionName = type.GetGenericTypeDefinition().Name;
            var allowedListEntry = allowedTypes.SingleOrDefault(allowedType => allowedType.FullName == genericDefinitionName);
            if (allowedListEntry == null)
            {
                throw new Exception($"Type '{type.Name}' is not allowed.");
            }

            if (allowedListEntry.IsGenericTypeDefinition != type.IsConstructedGenericType)
            {
                throw new Exception($"Invalid operation: allowed list entry '{allowedListEntry.FullName}' does not match typeId '{type}'.");
            }

            if (type.GetGenericParameterCount() != allowedListEntry.GetGenericArguments().Length)
            {
                throw new Exception($"Invalid operation: allowed list entry '{allowedListEntry.FullName}' does not match typeId '{type}' with regard to the number of generic arguments.");
            }

            var genericParameters = type
                .GetGenericParameters()
                .Select(x => ConstructTypeFromAllowedlist(x, allowedTypes))
                .ToArray();

            return allowedListEntry.MakeGenericType(genericParameters);
        }
    }
}