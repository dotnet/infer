// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

namespace Microsoft.ML.Probabilistic.Serialization
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Reflection;
    using System.Runtime.Serialization;
    using System.Xml;

    /// <summary>
    /// A data contract resolver that dynamically resolves known types.
    /// </summary>
    public class InferDataContractResolver : DataContractResolver
    {
        // URN prefix of namespaces generated by our contract resolver
        private const string nsPrefix = "urn:x-research.microsoft.com:Infer.NET:assemblyname:";

        private static Dictionary<string, Type> allowedTypes = GetAllowedTypes();

        private static Dictionary<string, Type> GetAllowedTypes()
        {
            // If this list isn't long enough then users can add to KnownTypes any types
            // they need. The exception thrown is very informative regarding which types are
            // allowed.
            var allowedTypes = new List<Type>
            {
                typeof(Char),
                typeof(SortedList<,>),
                typeof(Double),
                typeof(String),
                typeof(Tuple<>),
                typeof(Tuple<,>),
                typeof(Tuple<,,>),
                typeof(Tuple<,,,>),
                typeof(Tuple<,,,,>),
                typeof(List<>),
                typeof(Int32),
                typeof(Int64),
            };

            // Allow all types in Runtime
            var runtimeTypes = Assembly
                .GetExecutingAssembly()
                .GetTypes();
            allowedTypes.AddRange(runtimeTypes);

            return allowedTypes.ToDictionary(x => x.FullName);
        }

        public override bool TryResolveType(
            Type type,
            Type declaredType,
            DataContractResolver knownTypeResolver,
            out XmlDictionaryString typeName,
            out XmlDictionaryString typeNamespace)
        {
            if (knownTypeResolver.TryResolveType(type, declaredType, knownTypeResolver, out typeName, out typeNamespace))
            {
                return true;
            }

            var dict = new XmlDictionary(2);
            typeName = dict.Add(type.FullName); 
            typeNamespace = dict.Add(String.Concat(nsPrefix, type.Assembly.FullName));
            return true;
        }

        public override Type ResolveName(string typeName, string typeNamespace, Type declaredType, DataContractResolver knownTypeResolver)
        {
            var ty = knownTypeResolver.ResolveName(typeName, typeNamespace, declaredType, knownTypeResolver);

            if (ty != null) return ty;
            
            if (!typeNamespace.StartsWith(nsPrefix)) // Is this our namespace?
            {
                return null; // Cannot resolve.
            }

            // We limit the length of the type name we are willing to try to parse
            // for security reasons.
            if (typeName.Length > 10000)
            {
                throw new Exception("Type name exceeded maximum length");
            }

            return ConstructTypeFromString(typeName);
        }

        internal static Type ConstructTypeFromString(string typeString)
        {
            // We avoid loading a type from a string for security reasons before we
            // first parse it to ensure that it is constructed from approved types.
            var typeLayout = GetTypeLayout(typeString);

            // We now construct the types entirely from the allowed list, using the 
            // type layout to direct how we combine types in the allowed list.
            // This means that even if the data is tampered with, a type is never
            // loaded -- types are only constructed as combinations of types in the
            // allowed list.
            return ConstructTypeFromAllowedlist(typeLayout);
        }

        /// <summary>
        /// Some information about the layout of a type.
        /// </summary>
        internal sealed class TypeId
        {
            /// <summary>
            /// The name of the type (without array marker or argument list).
            /// </summary>
            public string Name { get; }

            /// <summary>
            /// Gets the type arguments.
            /// </summary>
            public TypeId[] Arguments { get; }

            /// <summary>
            /// Gets whether or not it is an array type.
            /// </summary>
            public bool IsArray { get; }

            /// <summary>
            /// Initializes an instance of <see cref="TypeId"/>.
            /// </summary>
            /// <param name="name">The name of the type (without array marker or argument list).</param>
            /// <param name="arguments">Gets the type arguments.</param>
            /// <param name="isArray">Gets whether or not it is an array type.</param>
            public TypeId(
                string name,
                TypeId[] arguments,
                bool isArray)
            {
                Name  = name;
                Arguments = arguments;
                IsArray = isArray;
            }
        }

        /// <summary>
        /// Read the type name extension (this is extra information beyond the type name,
        /// array marker, and argument list, such as the assembly information).
        /// </summary>
        /// <param name="typeString">The type string.</param>
        /// <param name="cursor">The index in the type string to read from.</param>
        /// <returns>
        /// If there is no extension, then cursor is returned; if there is an extension
        /// then one after the end of the extension is returned.
        /// </returns>
        private static int ReadTypeNameExtension(string typeString, int cursor)
        {
            if (cursor == typeString.Length)
            {
                return cursor;
            }

            // The start of the extension is marked with a comma.
            if (typeString[cursor] != ',')
            {
                return cursor;
            }

            while (true)
            {

                // If we reached the end of the string there is nothing following to read.
                if (typeString.Length == cursor)
                {
                    return cursor;
                }

                // If we reached the typename list item delimiter there is nothing following to read.
                if (typeString[cursor] == ']')
                {
                    return cursor;
                }

                cursor++;
            }
        }

        /// <summary>
        /// Read the array marker if it exists.
        /// </summary>
        /// <param name="typeString">The type string.</param>
        /// <param name="cursor">The index in the type string to read from.</param>
        /// <returns>
        /// cursor:
        /// If there is no extension, then cursor is returned; if there is an array marker
        /// then one after the end of the extension is returned.
        /// 
        /// isArray:
        /// whether or not there is an array marker.
        /// </returns>
        private static (int cursor, bool isArray) ReadArrayMarker(string typeString, int cursor)
        {
            // An array marker is "[]" so we just see if it is present.
            if (cursor == typeString.Length)
            {
                return (cursor, isArray: false);
            }

            if (typeString[cursor] != '[')
            {
                return (cursor, isArray: false);
            }

            if (cursor + 1 == typeString.Length)
            {
                throw new InvalidOperationException("Invalid type string");
            }

            if (typeString[cursor + 1] == ']')
            {
                return (cursor + 2, isArray: true);
            }

            return (cursor, isArray: false);
        }

        /// <summary>
        /// Read the type name.
        /// </summary>
        /// <param name="typeString">The type string.</param>
        /// <param name="cursor">The index in the type string to read from.</param>
        /// <returns>
        /// cursor:
        /// One after the last index of the current type name.
        /// 
        /// isArray:
        /// The TypeId of the read type.
        /// </returns>
        private static (int cursor, TypeId typeId) ReadTypeName(string typeString, int cursor)
        {
            // The format of a type name is
            // Name[PossibleArgumentList][PossibleArrayMarker][PossibleExtension]
            var startOfTypeName = cursor;

            // First read the actual type name.
            while (true)
            {
                if (typeString.Length < cursor)
                {
                    throw new InvalidOperationException("invalid type name.");
                }

                // If we reached the end of the string there is nothing following to read.
                if (typeString.Length == cursor)
                {
                    break;
                }

                if (typeString[cursor] == '[' || typeString[cursor] == ',')
                {
                    break;
                }

                cursor++;
            }

            var name = typeString.Substring(startOfTypeName, cursor - startOfTypeName);

            TypeId[] list;
            (cursor, list) = ReadTypeList(typeString, cursor);

            bool isArray;
            (cursor, isArray) = ReadArrayMarker(typeString, cursor);

            cursor = ReadTypeNameExtension(typeString, cursor);
            return (cursor, new TypeId(name, list, isArray));
        }

        /// <summary>
        /// Read the type name name list if it is present.
        /// </summary>
        /// <param name="typeString">The type string.</param>
        /// <param name="cursor">The index in the type string to read from.</param>
        /// <returns>
        /// cursor:
        /// One after the last index of the type name list if it exists.
        /// Returns the orignal cursor otherwise.
        /// 
        /// types:
        /// The TypeIds of the read types in the list.
        /// </returns>
        private static (int cursor, TypeId[] types) ReadTypeList(string typeString, int cursor)
        {
            // Type lists are delimited with square brackets, as is each type in the list, and they are separated by commas.
            // For example, X`4[[A],[B],[C],[D]]
            var list = new List<TypeId>();

            if (typeString.Length == cursor)
            {
                return (cursor, new TypeId[0]);
            }

            if (typeString[cursor] != '[')
            {
                return (cursor, new TypeId[0]); 
            }

            if (typeString[cursor + 1] == ']')
            {
                return (cursor, new TypeId[0]);
            }

            cursor++;

            while (true)
            {
                if (typeString[cursor] != '[')
                {
                    throw new InvalidOperationException("invalid type list element.");
                }
                cursor++;

                TypeId item;
                (cursor, item) = ReadTypeName(typeString, cursor);
                list.Add(item);

                if (typeString.Length < cursor)
                {
                    throw new InvalidOperationException("invalid cursor.");
                }

                if (typeString.Length == cursor)
                {
                    throw new InvalidOperationException("truncated type string.");
                }

                // Check for the closing bracket of the 
                if (typeString[cursor] != ']')
                {
                    throw new InvalidOperationException("invalid type string.");
                }

                cursor++;

                // there is not another item.
                if (typeString[cursor] != ',')
                {
                    break;
                }

                cursor++;
            }

            if (typeString[cursor] != ']')
            {
                throw new InvalidOperationException("invalid type list termination.");
            }
            cursor++;

            return (cursor, list.ToArray());
        }

        /// <summary>
        /// Parse a type string into a type layout which gives basic information
        /// about the makeup of the type.
        /// </summary>
        /// <param name="typeString">The type string.</param>
        /// <returns>
        /// Basic information about how the type is constructed from other types.
        /// </returns>
        internal static TypeId GetTypeLayout(string typeString)
        {
            var (endOfString, typeId) = ReadTypeName(typeString, cursor: 0);
            if (endOfString != typeString.Length)
            {
                throw new InvalidOperationException("Invalid type string");
            }

            return typeId;
        }

        internal static Type ConstructTypeFromAllowedlist(TypeId type)
        {
            // To avoid any possibility that an unexpected type is extracted from the string
            // this method creates the type entirely from the allowedTypes list. That way even
            // if there is an error in parsing of the type it is not possible for any type not
            // in the allowed list to be created.
            if (type.IsArray)
            {
                var itemType = new TypeId(type.Name, type.Arguments, isArray: false);
                var resolvedItemType = ConstructTypeFromAllowedlist(itemType);
                return resolvedItemType.MakeArrayType();
            }

            if (type.Arguments.Length == 0)
            {
                if (!allowedTypes.TryGetValue(type.Name, out var simpleType))
                {
                    throw new Exception($"Type '{type.Name}' is not allowed.");
                }

                return simpleType;
            }

            var genericDefinitionName = type.Name;
            if (!allowedTypes.TryGetValue(genericDefinitionName, out var allowedListEntry))
            {
                throw new Exception($"Type '{type.Name}' is not allowed.");
            }

            if (type.Arguments.Length != allowedListEntry.GetGenericArguments().Length)
            {
                throw new Exception($"Invalid operation: allowed list entry '{allowedListEntry.FullName}' does not match typeId '{type}' with regard to the number of generic arguments.");
            }

            var genericParameters = type
                .Arguments
                .Select(x => ConstructTypeFromAllowedlist(x))
                .ToArray();

            return allowedListEntry.MakeGenericType(genericParameters);
        }
    }
}